clc
clear all
% This script is used to derive the inverse kinematics, jacobian and Jacobian
% derivative,M matrix,C matrix and N vector symbollically which are
% then auto-exported as helper functions in the main file.
% Reading the helper functions is not useful as they are autogenerated.
%
% Please note that it is not neccessary to execute this script
% but if required it takes about 3 mins to completely execute 
% as the function exporter takes time to implement optimized versions for
% fast execution.

%tic

% Creating Symbolic Parameters

syms m1 m2 m3 m4 real
syms r1 r2 r3 r4 real
syms l1 l2 l3 l4 l0 real
syms grav real
parameters = [m1 m2 m3 m4 r1 r2 r3 r4 l1 l2 l3 l4 l0 grav].';

%Creating symbolic variables and functions
syms q1(t) q2(t) q3(t) q4(t) 
pos = [q1(t) q2(t) q3(t) q4(t)].';
vel = diff(pos,t);
acc = diff(vel,t);
state = [pos;vel;acc];

%Dummy variables for differentiation
q = sym('q', [4 1]);
q_d = sym('q_d',[4 1]);
q_dd = sym('q_dd',[4 1]);
dummy = [q; q_d; q_dd];

%% Inverse Kinematics Derivation

syms start1 start2 start3 start4 real %% x y z yaw for inverse kinematics 

%Extracting Kinematic equations of gripper
[~,gripper]=manipulator_pos(dummy(1:4),l1,l2,l0);

%Solving Kinematic equations for joint space vector
% Using q1 = atan2(start1,start2) and q3 = start4
ikin = subs(gripper.'-[start1 start2 start3 start4].',[dummy(1) dummy(3)],[atan2(start1,start2) start4]); 
ikin = [ikin(1);ikin(3)];
[q2sol,q4sol] = solve(ikin,[dummy(2) dummy(4)]);
%Note: There are multiple solutions to the above problem.The solution
%corresponding to elbow down 1st Octant arm is chosen.
matlabFunction([q2sol,q4sol],'File','ikin','Vars',{[start1 start2 start3 start4],l1,l2,l0},'Outputs',{'ikin_sol'});

%% Jacobian Derivation

J = [diff(gripper(1),dummy(1)) diff(gripper(1),dummy(2)) diff(gripper(1),dummy(3)) diff(gripper(1),dummy(4))
    diff(gripper(2),dummy(1)) diff(gripper(2),dummy(2)) diff(gripper(2),dummy(3)) diff(gripper(2),dummy(4))
    diff(gripper(3),dummy(1)) diff(gripper(3),dummy(2)) diff(gripper(3),dummy(3)) diff(gripper(3),dummy(4))
    diff(gripper(4),dummy(1)) diff(gripper(4),dummy(2)) diff(gripper(4),dummy(3)) diff(gripper(4),dummy(4))];

Jdot = subs(diff(subs(J,dummy,state),t),state,dummy);
% Exporting Matlab Function which generates the J and Jdot matrix given q
% and qdot with l1 l2 l0
matlabFunction(J,Jdot,'File','jac','Vars',{dummy(1:4),dummy(5:8),l1,l2,l0},'Outputs',{'J','Jdot'});


%% Rotation Matrices and Transforms from frame S-A-B-C-T
R_SA=[cos(pos(1)) -sin(pos(1)) 0; sin(pos(1)) cos(pos(1)) 0;0 0 1]; %Frame S to A
R_AB=[1 0 0;0 cos(pos(2)) -sin(pos(2));0 sin(pos(2)) cos(pos(2))]; % Frame A to B
R_BC=eye(3); %Frame B to C
R_CT=[cos(pos(3)) -sin(pos(3)) 0; sin(pos(3)) cos(pos(3)) 0;0 0 1]; %Frame C to T

H_SA=[R_SA [0 0 0].';0 0 0 1]; %Frame S to A
H_AB=[R_AB [0 l1 0].';0 0 0 1]; % Frame A to B
H_BC=[R_BC [0 l2 0].';0 0 0 1]; %Frame B to C
H_CT=[R_CT [0 0 pos(4)-l0].';0 0 0 1]; %Frame C to T

%% Position Vectors of Centre of gravity of links in World frame S

% Positions are generated using forward composition of homogenous
% transforms
p1h = H_SA*[0 (l1/2) 0 1].'; % Homogenous coordinates
p1 = p1h(1:3);
p2h = H_SA*H_AB*[0 (l2/2) 0 1].'; % Homogenous coordinates
p2 = p2h(1:3);
p3h = H_SA*H_AB*H_BC*[0 0 0 1].'; % Homogenous coordinates
p3 = p3h(1:3);
p4h = H_SA*H_AB*H_BC*H_CT*[0 0 0 1].'; % Homogenous coordinates
p4 = p4h(1:3);

%% Link Jacobians for Static Torque computation

p1h = subs(p1h,state,dummy);
p2h = subs(p2h,state,dummy);
p3h = subs(p3h,state,dummy);
p4h = subs(p4h,state,dummy);

J_link1 = [diff(p1h(1),dummy(1)) diff(p1h(1),dummy(2)) diff(p1h(1),dummy(3)) diff(p1h(1),dummy(4))
    diff(p1h(2),dummy(1)) diff(p1h(2),dummy(2)) diff(p1h(2),dummy(3)) diff(p1h(2),dummy(4))
    diff(p1h(3),dummy(1)) diff(p1h(3),dummy(2)) diff(p1h(3),dummy(3)) diff(p1h(3),dummy(4))
    diff(p1h(4),dummy(1)) diff(p1h(4),dummy(2)) diff(p1h(4),dummy(3)) diff(p1h(4),dummy(4))];

J_link2 = [diff(p2h(1),dummy(1)) diff(p2h(1),dummy(2)) diff(p2h(1),dummy(3)) diff(p2h(1),dummy(4))
    diff(p2h(2),dummy(1)) diff(p2h(2),dummy(2)) diff(p2h(2),dummy(3)) diff(p2h(2),dummy(4))
    diff(p2h(3),dummy(1)) diff(p2h(3),dummy(2)) diff(p2h(3),dummy(3)) diff(p2h(3),dummy(4))
    diff(p2h(4),dummy(1)) diff(p2h(4),dummy(2)) diff(p2h(4),dummy(3)) diff(p2h(4),dummy(4))];

J_link3 = [diff(p3h(1),dummy(1)) diff(p3h(1),dummy(2)) diff(p3h(1),dummy(3)) diff(p3h(1),dummy(4))
    diff(p3h(2),dummy(1)) diff(p3h(2),dummy(2)) diff(p3h(2),dummy(3)) diff(p3h(2),dummy(4))
    diff(p3h(3),dummy(1)) diff(p3h(3),dummy(2)) diff(p3h(3),dummy(3)) diff(p3h(3),dummy(4))
    diff(p3h(4),dummy(1)) diff(p3h(4),dummy(2)) diff(p3h(4),dummy(3)) diff(p3h(4),dummy(4))];

% Note that link J_gripper is same as the previously computed J
J_gripper = J;

matlabFunction(J_link1,J_link2,J_link3,J_gripper,'File','link_jacs','Vars',{dummy(1:4),l1,l2,l0},'Outputs',{'J_link1','J_link2','J_link3','J_link4'});

%% Velocity Vectors of Centre of gravity of links in  World frame S

v1 = diff(p1,t);
v2 = diff(p2,t);
v3 = diff(p3,t);
v4 = diff(p4,t);

%% Inertia Matrices

I1 = [(1/12)*m1*(3*r1^2 + l1^2) 0 0
    0 (1/2)*m1*r1^2 0
    0 0 (1/12)*m1*(3*r1^2 + l1^2)];


I2 = [(1/12)*m2*(3*r2^2 + l2^2) 0 0
    0 (1/2)*m2*r2^2 0
    0 0 (1/12)*m2*(3*r2^2 + l2^2)];


I3 = [(1/12)*m3*(3*r3^2 + l3^2) 0 0
    0 0 (1/12)*m3*(3*r3^2 + l3^2)
    0 (1/2)*m3*r3^2 0];


I4 = [(1/12)*m4*(3*r4^2 + l4^2) 0 0
    0 0 (1/12)*m4*(3*r4^2 + l4^2)
    0 (1/2)*m4*r4^2 0];

% Inertia Matrices in World Frame S

I1_S = (R_SA)*I1*(R_SA).';
I2_S = (R_SA*R_AB)*I2*(R_SA*R_AB).';
I3_S = (R_SA*R_AB*R_BC)*I3*(R_SA*R_AB*R_BC).';
I4_S = (R_SA*R_AB*R_BC*R_CT)*I4*(R_SA*R_AB*R_BC*R_CT).';

%% Angular Velocities of links in  World frame S

% Angular velocities of links in each frame are generated by
% differentiating their corresponding Rotation Matrices
omega1m = diff(R_SA,t)*(R_SA).';
omega1 = [-omega1m(2,3) omega1m(1,3) -omega1m(1,2)].';
omega2m = diff(R_SA*R_AB,t)*(R_SA*R_AB).';
omega2 = [-omega2m(2,3) omega2m(1,3) -omega2m(1,2)].';
omega3m = diff(R_SA*R_AB*R_BC,t)*(R_SA*R_AB*R_BC).';
omega3 = [-omega3m(2,3) omega3m(1,3) -omega3m(1,2)].';
omega4m = diff(R_SA*R_AB*R_BC*R_CT,t)*(R_SA*R_AB*R_BC*R_CT).';
omega4 = [-omega4m(2,3) omega4m(1,3) -omega4m(1,2)].';

%% Lagrangian 

KE1 = (1/2)*m1*(v1.')*v1 + (1/2)*omega1.'*I1*omega1; 
KE2 = (1/2)*m2*(v2.')*v2 + (1/2)*omega2.'*I2*omega2;
KE3 = (1/2)*m3*(v3.')*v3 + (1/2)*omega3.'*I3*omega3; 
KE4 = (1/2)*m4*(v4.')*v4 + (1/2)*omega4.'*I4*omega4;

PE1 = m1*grav*p1h(3);
PE2 = m2*grav*p2h(3);
PE3 = m3*grav*p3h(3);
PE4 = m4*grav*p4h(3);

L = KE1+KE2+KE3+KE4-(PE1+PE2+PE3+PE4);
L_dummy = subs(L,state,dummy); % L using dummy variables for differentiation

%% Deriving Equations of Motion in frame S

dL_dq1 = diff(L_dummy,dummy(1));
dL_dq2 = diff(L_dummy,dummy(2));
dL_dq3 = diff(L_dummy,dummy(3));
dL_dq4 = diff(L_dummy,dummy(4));

dL_dq1dot = subs(diff(L_dummy,dummy(5)),dummy,state);
dL_dq2dot = subs(diff(L_dummy,dummy(6)),dummy,state);
dL_dq3dot = subs(diff(L_dummy,dummy(7)),dummy,state);
dL_dq4dot = subs(diff(L_dummy,dummy(8)),dummy,state);

eqn1 = subs(diff(dL_dq1dot,t),state,dummy) - dL_dq1;
eqn2 = subs(diff(dL_dq2dot,t),state,dummy) - dL_dq2;
eqn3 = subs(diff(dL_dq3dot,t),state,dummy) - dL_dq3;
eqn4 = subs(diff(dL_dq4dot,t),state,dummy) - dL_dq4;

%% Deriving M matrix (also called INERTIA matrix)

% Using equationsToMatrix builtin function to generate Inertia Matrix M
% such that M*q_dotdot = RHS where RHS contains the coriolis vector c and
% Gravity Vector N
[INERTIA,RHS] = equationsToMatrix([eqn1==0;eqn2==0;eqn3==0;eqn4==0],dummy(9:12));
matlabFunction(INERTIA,'File','inertia','Vars',{dummy(1:4),parameters},'Outputs',{'inertia_matrix'});


% Exporting Matlab Function which generates the M (Inertia) matrix given q and
% parameters
INERTIA_dot = subs(diff(subs(INERTIA,dummy,state),t),state,dummy);

%% Deriving Coriolis Matrix

CORIOLIS = sym('CORIOLIS', [4 4]);

% Christophel symbol approach to generate C such that M_dot - 2C is skew
% symmetric
for i=1:4
    for j=1:4
        C = 0;
        for k=1:4
             C = C + (1/2)*(diff(INERTIA(i,j),dummy(k))+diff(INERTIA(i,k),dummy(j))-diff(INERTIA(k,j),dummy(i)))*dummy(k+4);       
        end
        CORIOLIS(i,j) = C;
    end
end

% Exporting Matlab Function which generates the Coriolis matrix given q and
% q_dot and parameters
matlabFunction(CORIOLIS,'File','coriolis','Vars',{dummy(1:4),dummy(5:8),parameters},'Outputs',{'coriolis_matrix'});

%% Deriving Gravity Vector
GRAVITY = -(RHS + CORIOLIS*dummy(5:8)); %multiplied by negative to bring to LHS

% Exporting Matlab Function which generates the N (gravity) Vector given q and
% q_dot and parameters
matlabFunction(GRAVITY,'File','gravity','Vars',{dummy(1:4),dummy(5:8),parameters},'Outputs',{'gravity_vector'});

INERTIA=simplify(INERTIA)

CORIOLIS=simplify(CORIOLIS)

GRAVITY=simplify(GRAVITY)

%toc









